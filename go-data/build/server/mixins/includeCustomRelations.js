"use strict";const _=require("lodash"),app=require("../server");module.exports=function(e){e.customRelations&&(e.observe("access",function(n,i){!function(n,i){const t=_.get(n,"options.includeCustom",[]);let o=_.get(n,"query.include",[]),r=o=Array.isArray(o)?o:[o];o.forEach(function(n){"string"==typeof n?e.customRelations[n]&&(r=r.filter(function(e){return e!==n}),t.push({relation:n,definition:e.customRelations[n]})):n.relation&&e.customRelations[n.relation]&&(r=r.filter(function(e){return e.relation!==n.relation}),t.push(Object.assign(n,{definition:e.customRelations[n.relation]})))}),_.set(n,"query.include",r),_.set(n,"options.includeCustom",t),_.set(n,"query.includeCustom",t),i()}(n,i)}),e.observe("loaded",function(e,n){(function(e,n){let i,t,o=_.get(e,"options.includeCustom",[]),r=[];return o.forEach(function(e){let o;switch(e.definition.type){case"belongsToMany":o={where:{id:{inq:_.get(n,e.definition.foreignKey)||[]}}};break;case"belongsToEmbedded":o={where:{id:{inq:[_.get(n,e.definition.foreignKey)]}}};break;case"belongsToManyComplex":i=n[e.definition.foreignKeyContainer],t=[],Array.isArray(i)&&i.forEach(function(n){t.push(_.get(n,e.definition.foreignKey))}),o={where:{id:{inq:t}}};break;case"hasManyEmbedded":o={where:{[e.definition.foreignKey]:n.id}};break;case"function":o={fn:e.definition.fn};break;default:throw new Error(`Unsupported custom relation type: ${e.definition.type}`)}e.scope&&(o=app.utils.remote.mergeFilters(o,e.scope)),"function"!==e.definition.type?r.push(app.models[e.definition.model].find(o).then(function(i){"belongsToEmbedded"===e.definition.type&&(i=i.shift()),n[e.relation]=i})):r.push(o.fn(n).then(function(i){n[e.relation]=i}))}),Promise.all(r)})(e,e.data).then(function(){n()}).catch(n)}))};