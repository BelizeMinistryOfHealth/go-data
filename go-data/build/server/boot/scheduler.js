"use strict";const moment=require("moment"),async=require("async"),fs=require("fs"),path=require("path"),configSettings=require("../../server/config.json"),syncActionsSettings=configSettings.sync,SyncClient=require("../../components/syncClient"),tmp=require("tmp"),logger=require("./../../components/logger"),shouldExecute=function(e,t,r){return moment().isAfter(moment(e).add(t,{h:"hours",m:"minutes",d:"days"}[r]))},automaticSyncID="Scheduled automatic sync";module.exports=function(e){function t(t){let r={upstreamServerURL:t.url},n={remotingContext:{req:{authData:{user:{id:automaticSyncID}},headers:{},connection:{}}}};e.logger.debug(`Scheduled automatic sync: Started sync with server '${t.name}'`),e.models.sync.sync(r,n,function(r,n){r?e.logger.debug(`Scheduled automatic sync: Sync with server '${t.name}' failed with error: ${r}`):e.logger.debug(`Scheduled automatic sync: Sync with server '${t.name}' is progressing having sync log ID ${n}`)})}let r,n=path.resolve(__dirname,"scheduler.json"),a=require("../../components/backup"),s=[t=>{a.preRoutine((n,s)=>{if(n)return e.logger.warn("Failed to setup backup create job"),t();const i=s.backupInterval;if(i<1)return r.backup&&delete r.backup,e.logger.warn("Backup interval is less than configured threshold."),t();r.backup?r.backup.interval=i:r.backup={startTime:moment(),lastExecutedTime:null,timeUnit:"h",interval:i};let c=r.backup,o=c.lastExecutedTime?c.lastExecutedTime:c.startTime;if(shouldExecute(o,c.interval,c.timeUnit)){c.lastExecutedTime=moment();const t=e.models.backup;t.create({date:Date.now(),modules:s.modules,location:null,userId:null,status:t.status.PENDING,automatic:!0}).then(e=>{a.create(s.modules,s.location,(r,n)=>{let a=t.status.SUCCESS;r&&(a=t.status.FAILED),e.updateAttributes({status:a,location:n})})})}return t()})},t=>{a.preRoutine((n,s)=>{if(n)return e.logger.warn("Failed to setup backup create job"),t();const i=s.dataRetentionInterval;if(i<1)return r.backupCleanup&&delete r.backupCleanup,e.logger.warn("Backup retention interval is less than configured threshold."),t();r.backupCleanup?r.backupCleanup.interval=i:r.backupCleanup={startTime:moment(),lastExecutedTime:null,timeUnit:"d",interval:i};let c=r.backupCleanup,o=c.lastExecutedTime?c.lastExecutedTime:c.startTime;return shouldExecute(o,c.interval,c.timeUnit)&&(c.lastExecutedTime=moment(),a.removeBackups({where:{date:{lt:new Date(o)},automatic:!0}})),t()})},t=>{let r=syncActionsSettings.actionCleanupInterval||24;return e.models.databaseActionLog.updateAll({status:"LNG_SYNC_STATUS_IN_PROGRESS",actionStartDate:{lt:new Date(moment().subtract(r,"hours"))}},{status:"LNG_SYNC_STATUS_FAILED",error:`Sync/export action was 'in progress' for more than ${r} hours`}).then(function(t){e.logger.debug(`Scheduler: ${t.count} sync/export actions that were 'in progress' for more than ${r} hours. Changed status to failed`)}).catch(function(t){e.logger.debug(`Scheduler: Update of 'in progress' sync/export actions status failed. Error: ${t}`)}),t()},n=>(e.models.systemSettings.getCache().then(function(e){r.sync=r.sync||{},e.upstreamServers=e.upstreamServers||[],e.upstreamServers.filter(function(e){return e.syncEnabled&&e.syncInterval>0}).forEach(function(e){if(r.sync[e.url]){let n=r.sync[e.url];n.interval=e.syncInterval,shouldExecute(n.lastExecutedTime||n.startTime,n.interval,n.timeUnit)&&(n.lastExecutedTime=moment(),t(e))}else r.sync[e.url]={startTime:moment(),lastExecutedTime:null,timeUnit:"h",interval:e.syncInterval}})}).catch(function(t){e.logger.debug(`Scheduler: Failed to schedule automatic sync. Error: ${t}`)}),n()),r=>(e.models.systemSettings.getCache().then(function(r){r.upstreamServers=r.upstreamServers||[];let n=r.upstreamServers.filter(function(e){return e.syncEnabled&&e.syncInterval>0}),a=[];return n.forEach(function(r){a.push(e.models.syncLog.findOne({where:{syncServerUrl:r.url},order:"actionStartDate DESC"}).then(function(n){if(n&&"LNG_SYNC_STATUS_FAILED"===n.status&&n.createdBy===automaticSyncID&&-1!==n.error.indexOf("EXTERNAL_API_CONNECTION_ERROR")){e.logger.debug(`Scheduler: Latest automatic sync with server '${r.name}' failed with connection error. Checking if connection was re-established.`),new SyncClient(r,{id:automaticSyncID}).getServerVersion().then(function(){e.logger.debug(`Scheduler: Connection with server '${r.name}' was re-established. Triggering automatic sync`),t(r)}).catch(function(t){e.logger.debug(`Scheduler: Connection with server '${r.name}' couldn't be re-established. Error: ${t}`)})}}))}),Promise.all(a)}).catch(function(t){e.logger.debug(`Scheduler: Failed to check for failed automatic sync. Error: ${t}`)}),r()),e=>{try{if(fs.existsSync(tmp.tmpdir)){const e=/^snapshot_\d{4}-\d{2}-\d{2}\_\d{2}-\d{2}-\d{2}.zip$/i,t=configSettings.removeSyncSnapshotsAfter||24,r=moment().subtract(t,"hours"),n=/^tmp-[a-zA-Z0-9\_]{10,20}$/i,a=/^upload_[a-zA-Z0-9\_]+$/i,s=configSettings.removeTmpUploadedFilesAfter||24,i=moment().subtract(s,"hours"),c=/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i,o=configSettings.removeTmpUploadedImportFilesAfter||24,u=moment().subtract(o,"hours"),l=e=>{const t=e=>{fs.existsSync(e)&&(fs.readdirSync(e).forEach(function(r){const n=`${e}${path.sep}${r}`;fs.lstatSync(n).isDirectory()?t(n):fs.unlinkSync(n)}),fs.rmdirSync(e))};try{t(e)}catch(e){logger.error(`Failed removing tmp uploaded directories: ${e}`)}},m=(e,t,r)=>{const n=`${tmp.tmpdir}${path.sep}${e}`;if(t.test(e)&&fs.existsSync(n)){const e=fs.statSync(n);if(e.birthtime&&moment(e.birthtime).isBefore(r))try{fs.lstatSync(n).isDirectory()?l(n):fs.unlinkSync(n)}catch(e){logger.error(`Failed removing tmp file / directory: ${e}`)}}};fs.readdirSync(tmp.tmpdir).forEach(function(t){m(t,e,r),m(t,n,r),m(t,a,i),m(t,c,u)})}}catch(e){logger.error(`Failed removing tmp snapshot files: ${e}`)}e()}];setInterval(()=>{try{r=JSON.parse(fs.readFileSync(n)),async.parallel(s,()=>{try{fs.writeFileSync(n,JSON.stringify(r))}catch(t){e.logger.warn(`Failed to write routines configuration. ${t}`)}})}catch(t){e.logger.error(`Failed to read routines configuration. ${t}`)}},12e4)};