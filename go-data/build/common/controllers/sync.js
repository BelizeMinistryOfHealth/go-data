"use strict";const fs=require("fs"),formidable=require("formidable"),app=require("../../server/server"),dbSync=require("../../components/dbSync"),_=require("lodash"),moment=require("moment");module.exports=function(e){function t(e,t,r=!0){return null==e&&!0===r&&t&&(e=t.clientId+t.clientSecret),e&&(e=app.utils.helpers.sha256(e)),e}function r(r,n,a,o,s,i,u,l){function p(e,t,r,n,a){if(r.actionCompletionDate=new Date,e?("NO-DATA"===e.code?e=app.utils.apiError.getError("SYNC_NO_DATA_TO_EXPORT"):e.toString=function(){return JSON.stringify(this)},app.logger.debug(`Export ${r.id}: Error ${e}`),r.status="LNG_SYNC_STATUS_FAILED",r.error=e):(app.logger.debug(`Export ${r.id}: Success`),r.status="LNG_SYNC_STATUS_SUCCESS",r.location=t),r.save(n).then(function(){app.logger.debug(`Export ${r.id}: Updated export log entry status.`)}).catch(function(e){app.logger.debug(`Export ${r.id}: Error updating export log entry status. ${e}`)}),a)return e?a(e):app.utils.remote.helpers.offerFileToDownload(fs.createReadStream(t),"application/octet-stream",t,a)}let c,S,g,d=Promise.resolve();i&&(d=app.models.user.findOne({where:{email:i}}).then(function(e){return e?(c=e,app.models.team.find({where:{userIds:e.id}})):Promise.reject(app.utils.apiError.getError("MODEL_NOT_FOUND",{model:app.models.user.modelName,id:i}))}).then(function(e){if(!e.length)return Promise.reject(app.utils.apiError.getError("SYNC_PACKAGE_FOR_USER_WITHOUT_TEAMS",{userEmail:i}));S=e.map(e=>e.id);let t=e.reduce(function(e,t){return e.concat(t.locationIds)},[]);return t=[...new Set(t)],new Promise(function(e,r){app.models.location.getSubLocations(t,[],function(t,n){return t?r(t):(g=n,e())})})})),d.then(function(){if(_.isEmpty(c))return;if(_.isEmpty(c.activeOutbreakId))throw app.utils.apiError.getError("NO_ACTIVE_OUTBREAK",{username:c.email});const e=_.get(u,"remotingContext.req.authData.client.outbreakIDs",[]);if(!_.isEmpty(e)&&e.indexOf(c.activeOutbreakId)<0)throw app.utils.apiError.getError("NO_ACCESS_TO_ACTIVE_OUTBREAK",{username:c.email})}).then(function(){n=n||!1,(r=r||{}).where=r.where||{},r.where.locationsIds=g,r.where.teamsIds=S,s=s||1e4;let i=_.get(r,"where.outbreakId");const d=_.get(u,"remotingContext.req.authData.client.outbreakIDs",[]),E=_.get(c,"outbreakIds",[]);let f=[];if(_.isEmpty(d))_.isEmpty(E)||(f=E);else if(_.isEmpty(E))f=d;else if(f=_.intersection(d,E),_.isEmpty(f))return l(app.utils.apiError.getError("ACCESS_DENIED",{accessErrors:"Client is not allowed to access any outbreaks with the provided credentials"},403));let h,y=[];if(i){let e=[];if("object"==typeof i&&null!==i&&Array.isArray(i.inq)?e=i.inq:"string"==typeof i&&(e=[i]),e.length){if(f.length){let t=e.filter(e=>-1===f.indexOf(e));if(t.length)return l(app.utils.apiError.getError("ACCESS_DENIED",{accessErrors:`Client is not allowed to access the following outbreaks: ${t.join(", ")}`},403))}else;y=e}}!y.length&&f.length&&(r.where.outbreakId={inq:f},y=f);let m=_.get(r,"where.exportType");if(-1!==Object.keys(dbSync.collectionsForExportTypeMap).indexOf(m))h=dbSync.collectionsForExportTypeMap[m];else{let e=_.get(r,"where.collections");h=Array.isArray(e)?e:dbSync.collectionsForExportTypeMap.mobile}return _.get(r,"where.includeUsers")&&(h=h.concat(dbSync.userCollections)),a=t(a,_.get(u,"remotingContext.req.authData.credentials"),o),app.models.databaseExportLog.create({syncClientId:_.get(u,"remotingContext.req.authData.client.credentials.clientId",`webUser: ${_.get(u,"remotingContext.req.authData.user.id","unavailable")}`),actionStartDate:new Date,status:"LNG_SYNC_STATUS_IN_PROGRESS",outbreakIDs:y},u).then(function(t){n?(l(null,t.id),e.exportDatabase(r,h,{password:a,chunkSize:s,exportEmptyCollections:!1},(e,r)=>{p(e,r,t,u)})):e.exportDatabase(r,h,{password:a,chunkSize:s,exportEmptyCollections:!1},(e,r)=>{p(e,r,t,u,l)})})}).catch(l)}e.getDatabaseSnapshot=function(e,t,n,a,o,s){r(e,!1,t,n,null,a,o,s)},e.getDatabaseSnapshotAsynchronous=function(e,t,n,a,o,s){r(e,!0,t,n,null,a,o,s)},e.getDatabaseSnapshotForMobile=function(e,t,n,a,o,s,i,u){Array.isArray(o.languageTokens)&&((e=e||{}).where=e.where||{},e.where.languageTokens=o.languageTokens),r(e,!1,t,n,a,s,i,u)},e.getExportedDatabaseSnapshot=function(e,t,r){app.models.databaseExportLog.findById(e).then(function(t){return t?"LNG_SYNC_STATUS_IN_PROGRESS"===t.status?r(app.utils.apiError.getError("INSTANCE_EXPORT_STILL_IN_PROGRESS")):"LNG_SYNC_STATUS_FAILED"===t.status?r(app.utils.apiError.getError("INSTANCE_EXPORT_FAILED",{error:t.error})):t.location&&fs.existsSync(t.location)?app.utils.remote.helpers.offerFileToDownload(fs.createReadStream(t.location),"application/octet-stream",t.location,r):(t.updateAttributes({status:"LNG_SYNC_STATUS_FAILED",error:"Export location is missing or file cannot be found"}).then(()=>{app.logger.debug(`Export ${t.id}: Updated DB export log entry status`)}).catch(e=>{app.logger.debug(`Export ${t.id}: Failed to save DB export log entry: Error ${e}`)}),r(app.utils.apiError.getError("INSTANCE_EXPORT_FAILED",{error:t.error}))):r(app.utils.apiError.getError("MODEL_NOT_FOUND",{model:app.models.databaseExportLog.modelName,id:e}))}).catch(r)},e.importDatabaseSnapshot=function(r,n,a,o,s,i,u,l){const p=app.utils.apiError.getError;function c(t,r,n,a){if(r.actionCompletionDate=new Date,t){app.logger.debug(`Sync ${r.id}: Error ${t}`),r.status=t.errorType===e.errorType.fatal?"LNG_SYNC_STATUS_FAILED":"LNG_SYNC_STATUS_SUCCESS_WITH_WARNINGS";let n=t.errorMessage;n&&("object"==typeof n&&(n.toString=function(){return JSON.stringify(this)}),r.error=n)}else app.logger.debug(`Sync ${r.id}: Success`),r.status="LNG_SYNC_STATUS_SUCCESS";if(r.save(n).then(function(){app.logger.debug(`Sync ${r.id}: Updated sync log entry status`)}).catch(function(e){app.logger.debug(`Sync ${r.id}: Error updating sync log entry status. ${e}`)}),a){if(t){let r="INSTANCE_SYNC_FAILED";"object"==typeof t&&(t.toString=function(){return JSON.stringify(this)},t.errorType===e.errorType.partial&&(r="INSTANCE_SYNC_PARTIAL_FAILURE")),t=p(r,{syncError:t})}return a(t,r.id)}}(new formidable.IncomingForm).parse(r,function(n,s,i){if(n)return l(n);if(!i.snapshot)return l(p("MISSING_REQUIRED_PROPERTY",{model:e.modelName,properties:"snapshot"}));a=s.asynchronous&&"true"===s.asynchronous;let u={remotingContext:{req:r}},S=_.get(r,"authData.client.outbreakIDs");Array.isArray(S)||(S=[]);let g=!0;null!=s.autoEncrypt&&("false"!==s.autoEncrypt&&"0"!==s.autoEncrypt||(g=!1));let d=!1;null==s.generatePersonVisualId||"true"!==s.generatePersonVisualId&&"1"!==s.generatePersonVisualId&&!0!==s.generatePersonVisualId&&1!==s.generatePersonVisualId||(d=!0);const E=t(s.password,_.get(u,"remotingContext.req.authData.credentials"),g);app.models.syncLog.create({syncClientId:_.get(r,"authData.client.credentials.clientId",`webUser: ${_.get(r,"authData.user.id","unavailable")}`),actionStartDate:new Date,status:"LNG_SYNC_STATUS_IN_PROGRESS",outbreakIDs:S},u).then(function(t){a?(l(null,t.id),e.syncDatabaseWithSnapshot(i.snapshot.path,t,S,u,o,{password:E,generatePersonVisualId:d},function(e){c(e,t,u)})):e.syncDatabaseWithSnapshot(i.snapshot.path,t,S,u,o,{password:E,generatePersonVisualId:d},function(e){c(e,t,u,l)})}).catch(l)})},e.getAvailableOutbreaksForClient=function(e,t){t(null,{outbreakIDs:e.remotingContext.req.authData.client.outbreakIDs||[]})},e.sync=function(r,n,a){if(!r.upstreamServerURL||"string"!=typeof r.upstreamServerURL)return a(app.utils.apiError.getError("REQUEST_VALIDATION_ERROR",{errorMessages:'Missing required property "upstreamServerURL"'}));let o,s,i,u=!1;app.models.systemSettings.getCache().then(function(t){if(!t)throw app.utils.apiError.getError("INTERNAL_ERROR",{error:"System Settings were not found"});if(i=t,!Array.isArray(i.upstreamServers)||!(o=i.upstreamServers.find(e=>e.url===r.upstreamServerURL)))throw app.utils.apiError.getError("UPSTREAM_SERVER_NOT_CONFIGURED",{upstreamServerURL:r.upstreamServerURL});if(!o.syncEnabled)throw app.utils.apiError.getError("UPSTREAM_SERVER_SYNC_DISABLED",{upstreamServerName:o.name,upstreamServerURL:o.url});if(e.inProgress.servers[o.url]&&!r.forceSync)throw app.utils.apiError.getError("UPSTREAM_SERVER_SYNC_IN_PROGRESS",{upstreamServerName:o.name,upstreamServerURL:o.url});return app.models.syncLog.create({syncServerUrl:o.url,actionStartDate:new Date,status:"LNG_SYNC_STATUS_IN_PROGRESS"},n)}).then(function(t){return s=t,e.inProgress.servers[o.url]=!0,a(null,s.id),u=!0,app.logger.debug(`Started sync ${s.id}`),e.getAvailableOutbreaksIDs(o,s)}).then(function(e){return app.logger.debug(`Sync ${s.id}: Sync will be done for ${e.length?"the following outbreaks: "+e.join(", "):"all the outbreaks in the system"}`),s.outbreakIDs=e,app.models.syncLog.findOne({where:{syncServerUrl:o.url,status:"LNG_SYNC_STATUS_SUCCESS"},order:"actionStartDate DESC"}).then(function(e){if(e){let t=moment(e.actionStartDate).subtract(1,"minutes");s.informationStartDate=t,app.logger.debug(`Sync ${s.id}: Latest successful sync with the upstream server (${o.url}) was done on '${new Date(s.informationStartDate).toISOString()}'. Syncing data from that date onwards`)}else app.logger.debug(`Sync ${s.id}: No successful sync was found for the upstream server with URL '${o.url}'. Syncing all data from the DB.`);return s.save(n)})}).then(function(){let r={where:{}};s.informationStartDate&&(r.where.fromDate=s.informationStartDate),Array.isArray(s.outbreakIDs)&&s.outbreakIDs.length&&(r.where.outbreakId={inq:s.outbreakIDs});let n=dbSync.syncCollections;const a=t(null,o.credentials,o.autoEncrypt);return app.logger.debug(`Sync ${s.id}: Exporting DB.`),new Promise(function(t,o){e.exportDatabase(r,n,{password:a,chunkSize:1e4},(e,r)=>e?o(e):(app.logger.debug(`Sync ${s.id}: DB exported at ${r}.`),t(r)))})}).then(function(t){return e.sendDBSnapshotForImport(o,t,!0,s)}).then(function(){s.actionCompletionDate=new Date,s.error?(app.logger.debug(`Sync ${s.id}: Success with warnings; ${s.error}`),s.status="LNG_SYNC_STATUS_SUCCESS_WITH_WARNINGS"):(app.logger.debug(`Sync ${s.id}: Success`),s.status="LNG_SYNC_STATUS_SUCCESS"),s.save(n).then(function(){app.logger.debug(`Sync ${s.id}: Updated sync log entry status.`)}).catch(function(e){app.logger.debug(`Sync ${s.id}: Error updating sync log entry status. ${e}`)}),e.inProgress.servers[o.url]=!1,e.checkAndTriggerPendingSync(o,n)}).catch(function(t){t.toString=function(){return JSON.stringify(this)},u?(app.logger.debug(`Sync ${s.id}: Error ${t}`),s.actionCompletionDate=new Date,s.status="LNG_SYNC_STATUS_FAILED",s.addError(t),s.save(n).then(function(){app.logger.debug(`Sync ${s.id}: Updated sync log entry status.`)}).catch(function(e){app.logger.debug(`Sync ${s.id}: Error updating sync log entry status. ${e}`)}),e.inProgress.servers[o.url]=!1,e.checkAndTriggerPendingSync(o,n)):(a(t),u=!0)})}};