"use strict";const app=require("../../server/server"),_=require("lodash"),async=require("async"),escapeRegExp=require("../../components/escapeRegExp");module.exports=function(e){e.hasController=!0,e.fieldLabelsMap=Object.assign({},e.fieldLabelsMap,{name:"LNG_LOCATION_FIELD_LABEL_NAME",synonyms:"LNG_LOCATION_FIELD_LABEL_SYNONYMS",identifiers:"LNG_LOCATION_FIELD_LABEL_IDENTIFIERS","identifiers[].code":"LNG_LOCATION_FIELD_LABEL_IDENTIFIERS_CODE","identifiers[].description":"LNG_LOCATION_FIELD_LABEL_IDENTIFIERS_DESC",active:"LNG_LOCATION_FIELD_LABEL_ACTIVE",populationDensity:"LNG_LOCATION_FIELD_LABEL_POPULATION_DENSITY",parentLocationId:"LNG_LOCATION_FIELD_LABEL_PARENT_LOCATION_ID",geoLocation:"LNG_LOCATION_FIELD_LABEL_GEO_LOCATION","geoLocation.lat":"LNG_LOCATION_FIELD_LABEL_GEO_LOCATION_LAT","geoLocation.lng":"LNG_LOCATION_FIELD_LABEL_GEO_LOCATION_LNG",geographicalLevelId:"LNG_LOCATION_FIELD_LABEL_GEOGRAPHICAL_LEVEL_ID"}),e.referenceDataFieldsToCategoryMap={geographicalLevelId:"LNG_REFERENCE_DATA_CATEGORY_LOCATION_GEOGRAPHICAL_LEVEL"},e.referenceDataFields=Object.keys(e.referenceDataFieldsToCategoryMap),e.noLocation={id:"-",name:"-"},e.arrayProps={synonyms:"LNG_LOCATION_FIELD_LABEL_SYNONYMS",identifiers:{code:"LNG_LOCATION_FIELD_LABEL_IDENTIFIERS_CODE",description:"LNG_LOCATION_FIELD_LABEL_IDENTIFIERS_DESC"}},e.getSubLocations=function(n,t,o){n||(n=[]),n.forEach(function(e){-1===t.indexOf(e)&&t.push(e)}),e.rawFind({parentLocationId:{inq:n}},{projection:{_id:1}}).then(function(n){if(n.length){const i=[];n.forEach(function(e){-1===t.indexOf(e.id)?i.push(e.id):app.logger.warn(`Detected loop in location hierarchy: location with id "${e.id}" is set as a child location for a location that is lower the hierarchy. Scanned locations ids: ${t.join(", ")}`)}),t=t.concat(i),e.getSubLocations(i,t,o)}else o(null,t)}).catch(o)},e.getSubLocationsWithDetails=function(n,t,o,i){let a,r=[],c={};t.forEach(e=>{r.push(e.id),c[e.id]=e}),Array.isArray(n)&&(a=n.filter(e=>!c[e]));let l={id:{nin:r}};a&&(l.or||(l.or=[]),l.or.push({id:{inq:a}})),n&&(l.or||(l.or=[]),l.or.push({parentLocationId:{inq:n}}));let s={where:l,order:["name ASC"]};o.fields&&(s.fields=o.fields),e.rawFindWithLoopbackFilter(s).then(function(n){if(n.length){let l=[];n.forEach(function(e){a&&-1===a.indexOf(e.id)&&(c[e.id]?app.logger.warn(`Detected loop in location hierarchy: location with id "${e.id}" is set as a child location for a location that is lower the hierarchy. Scanned locations ids: ${r.join(", ")}`):l.push(e.id))}),t=t.concat(n),e.getSubLocationsWithDetails(l,t,o,i)}else i(null,t)}).catch(i)},e.getParentLocationsWithDetails=function(n,t,o,i){let a=[],r=[],c=[],l={};t.forEach(e=>{l[e.id]=e}),n.forEach(function(e){l[e]?l[e].parentLocationId&&!l[l[e].parentLocationId]&&c.push(l[e].parentLocationId):r.push(e)}),a=a.concat(r,c);let s=Promise.resolve([]);if(a.length){let n={where:{id:{inq:a}},order:["name ASC"]};o.fields&&(n.fields=o.fields),s=e.rawFindWithLoopbackFilter(n)}s.then(function(n){if(n.length){let a=[];n.forEach(function(e){let n=e.parentLocationId;n&&!l[n]&&a.push(e.id)}),t=t.concat(n),a.length?e.getParentLocationsWithDetails(a,t,o,i):i(null,t)}else i(null,t)}).catch(i)},e.validateModelIdentifiers=function(n,t){let o=null;n.hasOwnProperty("parentLocationId")?o=n.parentLocationId||null:t&&(o=t.parentLocationId||null);let i="";n.hasOwnProperty("name")?i=n.name||"":t&&(i=t.name||""),i=new RegExp(["^",escapeRegExp(i),"$"].join(""),"i");let a=[];n.hasOwnProperty("synonyms")?a=n.synonyms||[]:t&&(a=t.synonyms||[]),a=a.map(e=>new RegExp(["^",escapeRegExp(e),"$"].join(""),"i"));let r="";return t&&(r=t.id),e.findOne({where:{id:{neq:r},parentLocationId:{eq:o},or:[{name:i},{synonyms:{in:a}}]}}).then(n=>{if(n){let t=[];throw i.test(n.name)&&t.push(`A location with name = '${n.name}' and the same parentLocationId already exists.`),n.synonyms&&a&&a.forEach(e=>{const o=n.synonyms.findIndex(n=>e.test(n));o>-1&&t.push(`A location with a '${n.synonyms[o]}' synonym and the same parentLocationId already exists.`)}),app.utils.apiError.getError("MODEL_IDENTIFIERS_ARE_NOT_UNIQUE_IN_CONTEXT",{model:e.modelName,details:t.join(" ")})}})},e.checkIfCanDelete=function(n){return e.findOne({where:{parentLocationId:n}}).then(t=>{if(t)throw app.utils.apiError.getError("DELETE_PARENT_MODEL",{model:e.modelName});return e.isRecordInUse(n)}).then(t=>{if(t)throw app.utils.apiError.getError("MODEL_IN_USE",{model:e.modelName,id:n})})},e.checkIfCanDeactivate=function(n,t){return e.findOne({where:{parentLocationId:t,active:!0}}).then(n=>{if(n)throw app.utils.apiError.getError("DEACTIVATE_PARENT_MODEL",{model:e.modelName})})},e.buildHierarchicalLocationsList=function(e,n,t){function o(e,n,t){e.children.forEach(function(e,i){let a=`${t}.children.${i}`;n[e.location.id]=a,e.children.length&&o(e,n,a)})}void 0===n&&(n=!1);let i=[],a={},r={};return e.forEach(function(e){e.toJSON&&(e=e.toJSON());let c,l=Object.assign({},e);!function(e){e.geoLocation&&e.geoLocation.coordinates&&null!=e.geoLocation.coordinates[0]&&null!=e.geoLocation.coordinates[1]&&(e.geoLocation={lat:e.geoLocation.coordinates[1],lng:e.geoLocation.coordinates[0]})}(l),n&&(delete l.id,delete l.parentLocationId);let s=!1;if(r[e.id]&&(_.set(i,`${a[e.id]}.location`,l),delete r[e.id],s=!0),null==e.parentLocationId||void 0!==e.geographicalLevelId&&e.geographicalLevelId===t)s||(c=i.push({location:l,children:[]}),a[e.id]=c-1);else if(void 0!==a[e.parentLocationId]){const n=_.get(i,a[e.parentLocationId]);let t={location:l,children:[]};s&&(t=JSON.parse(JSON.stringify(_.get(i,a[e.id]))),_.set(i,a[e.id],null)),c=n.children.push(t),a[e.id]=`${a[e.parentLocationId]}.children.${c-1}`,s&&o(t,a,a[e.id])}else{r[e.parentLocationId]=!0;let n={location:l,children:[]};s&&(n=JSON.parse(JSON.stringify(_.get(i,`${a[e.id]}`))),_.set(i,a[e.id],null)),c=i.push({location:null,children:[n]}),a[e.parentLocationId]=c-1,a[e.id]=`${c-1}.children.0`,s&&o(n,a,a[e.id])}}),(i=i.filter(e=>e&&e.location)).sort(function(e,n){return e.location.name===n.location.name?0:e.location.name>n.location.name?1:-1}),i},e.createLocationsFromHierarchicalLocationsList=function(n,t,o,i){"function"==typeof o&&(i=o,o={}),o.resultAccumulator||(o.resultAccumulator=[]);const a=[];t.forEach(function(t){let i=Object.assign({parentLocationId:n},t.location);i.updatedAt||(i.updatedAt=new Date),a.push(function(n){app.utils.dbSync.syncRecord(o.remotingContext.req.logger,app.models.location,i,o).then(function(i){const a=i.record;o.resultAccumulator.push(a),t.children&&t.children.length?e.createLocationsFromHierarchicalLocationsList(a.id,t.children,o,n):n(null,a)}).catch(n)})}),async.series(a,function(e){if(e)return i(e);i(null,o.resultAccumulator)})},e.importHierarchicalListFromJsonFile=function(n,t,o){try{const i="string"==typeof n?JSON.parse(n):n;if(!Array.isArray(i))return o(app.utils.apiError.getError("INVALID_CONTENT_OF_TYPE",{contentType:"JSON",details:"it should contain an array"}));e.createLocationsFromHierarchicalLocationsList(void 0,i,t,o)}catch(e){o(app.utils.apiError.getError("INVALID_CONTENT_OF_TYPE",{contentType:"JSON",details:e.message}))}},e.observe("before save",function(n,t){n.isNewInstance?e.validateModelIdentifiers(n.instance.toJSON()).then(()=>t()).catch(t):e.validateModelIdentifiers(n.data,n.currentInstance).then(()=>{if(!1===n.data.active)return e.checkIfCanDeactivate(n.data,n.currentInstance.id)}).then(()=>t()).catch(e=>t(e))}),e.observe("before delete",function(n,t){e.checkIfCanDelete(n.currentInstance.id).then(()=>t()).catch(t)}),e.createLocationCorelationMap=function(n,t,o){n.forEach(n=>{t.includes(n.location.id)?(o[n.location.id]=n.location.id,0!==n.children.length&&e.linkAllChildrenToTopLevel(n.children,n.location.id,o)):n.children.length&&e.createLocationCorelationMap(n.children,t,o)})},e.linkAllChildrenToTopLevel=function(n,t,o){n.forEach(n=>{o[n.location.id]=t,n.children.length&&e.linkAllChildrenToTopLevel(n.children,t,o)})},e.resolveLocationsWithLevel=function(e,n){const t=app.models;return new Promise((o,i)=>{let a;return Array.isArray(n.locationIds)&&n.locationIds.length&&(a=n.locationIds),t.location.getSubLocationsWithDetails(a,[],{},function(a,r){let c=r.map(e=>e.id),l=n.reportingGeographicalLevelId;return l?t.location.find({where:{and:[{id:{inq:c}},{geographicalLevelId:l}]}}).then(n=>{let i=n.map(e=>e.id),a=t.location.buildHierarchicalLocationsList(r),c={};app.models.location.createLocationCorelationMap(a,i,c);let l={};return e.forEach(e=>{let n=c[e];n&&(l[e]=n)}),o(l)}):i(app.utils.apiError.getError("MISSING_REQUIRED_PROPERTY",{model:t.outbreak.modelName,properties:"reportingGeographicalLevelId"}))})})}};